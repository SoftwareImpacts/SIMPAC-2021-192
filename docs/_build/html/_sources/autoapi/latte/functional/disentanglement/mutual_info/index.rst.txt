:py:mod:`latte.functional.disentanglement.mutual_info`
======================================================

.. py:module:: latte.functional.disentanglement.mutual_info

.. autoapi-nested-parse::

   
   ..
       !! processed by numpydoc !!


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   latte.functional.disentanglement.mutual_info._validate_za_shape
   latte.functional.disentanglement.mutual_info.get_mi_func
   latte.functional.disentanglement.mutual_info.latent_attr_mutual_info
   latte.functional.disentanglement.mutual_info.single_mutual_info
   latte.functional.disentanglement.mutual_info.entropy
   latte.functional.disentanglement.mutual_info.conditional_entropy
   latte.functional.disentanglement.mutual_info._mgap
   latte.functional.disentanglement.mutual_info._xgap
   latte.functional.disentanglement.mutual_info.mig
   latte.functional.disentanglement.mutual_info.dmig
   latte.functional.disentanglement.mutual_info.dlig
   latte.functional.disentanglement.mutual_info.xmig



.. py:function:: _validate_za_shape(z: numpy.ndarray, a: numpy.ndarray, reg_dim: Optional[List], fill_reg_dim: bool = False) -> Tuple[numpy.ndarray, numpy.ndarray]

   
















   ..
       !! processed by numpydoc !!

.. py:function:: get_mi_func(discrete: bool) -> Callable

   
















   ..
       !! processed by numpydoc !!

.. py:function:: latent_attr_mutual_info(z: numpy.ndarray, a: numpy.ndarray, discrete: bool = False) -> numpy.ndarray

   
   Calculate mutual information between latent vectors and a target attribute.

   :param z: a batch of latent vectors
   :type z: np.ndarray, (n_samples, n_features)
   :param a: a batch of one attribute
   :type a: np.ndarray, (n_samples,)
   :param discrete: whether the attribute is discrete, by default False
   :type discrete: bool, optional

   :returns: mutual information between each latent vector dimension and the attribute
   :rtype: np.ndarray, (n_features,)















   ..
       !! processed by numpydoc !!

.. py:function:: single_mutual_info(a: numpy.ndarray, b: numpy.ndarray, discrete: bool) -> numpy.float

   
   [summary]

   :param a: [description]
   :type a: np.ndarray, (n_samples,)
   :param b: [description]
   :type b: np.ndarray, (n_samples,)
   :param discrete: [description]
   :type discrete: bool

   :returns: [description]
   :rtype: np.float















   ..
       !! processed by numpydoc !!

.. py:function:: entropy(a: numpy.ndarray, discrete: bool = False) -> numpy.float

   
   [summary]

   :param a: [description]
   :type a: np.ndarray, (n_samples,)
   :param discrete: [description], by default False
   :type discrete: bool, optional

   :returns: [description]
   :rtype: np.float















   ..
       !! processed by numpydoc !!

.. py:function:: conditional_entropy(ai: numpy.ndarray, aj: numpy.ndarray, discrete: bool = False) -> numpy.float

   
   [summary]

   :param ai: [description]
   :type ai: np.ndarray, (n_samples,)
   :param aj: [description]
   :type aj: np.ndarray, (n_samples,)
   :param discrete: [description], by default False
   :type discrete: bool, optional

   :returns: H(ai|aj) = H(ai) - I(ai, aj)
   :rtype: np.float















   ..
       !! processed by numpydoc !!

.. py:function:: _mgap(mi: numpy.ndarray, zi: Optional[int] = None) -> Tuple[numpy.ndarray, Optional[int]]

   
   [summary]

   :param mi: [description]
   :type mi: np.ndarray, (n_features,)
   :param zi: [description], by default None
   :type zi: t.Optional[int], optional

   :returns: * *np.ndarray* -- [description]
             * *t.Optional[int]* -- index of the unregularized latent dimension with the highest MI, `None` if `zi` is `None`















   ..
       !! processed by numpydoc !!

.. py:function:: _xgap(mi: numpy.ndarray, zi: int, reg_dim: List) -> Tuple[numpy.ndarray, Optional[int]]

   
   [summary]

   :param mi: [description]
   :type mi: np.ndarray, (n_features,)
   :param zi: [description], by default None
   :type zi: t.Optional[int], optional

   :returns: * *np.ndarray* -- [description]
             * *t.Optional[int]* -- index of the unregularized latent dimension with the highest MI, `None` if `zi` is `None`















   ..
       !! processed by numpydoc !!

.. py:function:: mig(z: numpy.ndarray, a: numpy.ndarray, reg_dim: Optional[List] = None, discrete: bool = False) -> numpy.ndarray

   
   [summary]

   :param z: [description]
   :type z: np.ndarray, (n_samples, n_features)
   :param a: [description]
   :type a: np.ndarray, (n_samples, n_attributes)
   :param reg_dim: [description], by default None
   :type reg_dim: t.Optional[t.List], optional
   :param discrete: [description], by default False
   :type discrete: bool, optional

   :returns: [description]
   :rtype: np.ndarray, (n_attributes,)















   ..
       !! processed by numpydoc !!

.. py:function:: dmig(z: numpy.ndarray, a: numpy.ndarray, reg_dim: Optional[List] = None, discrete: bool = False) -> numpy.ndarray

   
   [summary]

   :param z: [description]
   :type z: np.ndarray, (n_samples, n_features)
   :param a: [description]
   :type a: np.ndarray, (n_samples, n_attributes)
   :param reg_dim: [description], by default None
   :type reg_dim: t.Optional[t.List], optional
   :param discrete: [description], by default False
   :type discrete: bool, optional

   :returns: [description]
   :rtype: np.ndarray, (n_attributes,)















   ..
       !! processed by numpydoc !!

.. py:function:: dlig(z: numpy.ndarray, a: numpy.ndarray, reg_dim: Optional[List] = None, discrete: bool = False)

   
















   ..
       !! processed by numpydoc !!

.. py:function:: xmig(z: numpy.ndarray, a: numpy.ndarray, reg_dim: Optional[List] = None, discrete: bool = False)

   
















   ..
       !! processed by numpydoc !!

